#include <stdio.h>
#include <string.h>

int main() {

  unsigned int key = 0; 
  unsigned int final_key = 0;
  int i = 0;
  int nbytes = 4096;
  char *input = (char *) malloc(nbytes + 1);
  char *input_copy = (char *) malloc(nbytes + 1);
  int bytes_read = getline(&input, &nbytes, stdin);
  int length = strlen(input);
  memcpy(input_copy, input, length);

  // idea: encode, get final key, then decode a copy

  // initial key for length 1024 is 0, bc of xoring content length with ff 
  key = 0;

  // "normal" encode transformation to get the key from the final operation
  for (i=0; i < length; i++) {
    input[i] ^= key;
    key -= input[i];
  }
  final_key = key;
  fprintf(stderr, "Key found: [%u]\n", final_key);
  fprintf(stderr, "Encrypted string [");
  for (i=0; i < length; ++i) {
    fprintf(stderr, "%c", input[i]);
  }
  fprintf(stderr, "]\n");

  // use final key to craft a string that will go through encoding, yielding our desired result
  key = final_key;

  // decode input
  for (i=length-1; i >= 0; i--) {
    key += input_copy[i];
    input_copy[i] ^= key;
  }
  fprintf(stderr, "Crafted string [");

  printf("Content-Length: %d\n", length);
  for (i=0; i < length; ++i) {
    printf("%c", input_copy[i]);
    fprintf(stderr, "%c", input_copy[i]);
  }
  fprintf(stderr,"]\n");

  // key should be initial key here
  return 0;
}

